# 2022-10-02 WIL

[목록으로 돌아가기](/README.md)

실전 프로젝트 다섯째 주를 보냈다. 내일이 사실상 마지막 날이다.

---

## 실전 프로젝트 (09-26~10-02)

프로젝트가 진짜 마무리 단계에 접어들었다. 이번 주엔 여러 버그 수정과 함께 이미지 인코딩 기능을 주로 작업했다.

### 1. 이미지 인코딩

MVP에는 이미지 리사이징을 통한 썸네일 기능만이 들어있었다. 메인 페이지에서 원본 이미지를 로딩하지 않고, 축소된 썸네일을 로딩하는 것만으로도 속도 면에서 효과를 볼 수 있었다.

하지만 MVP 작업이 끝나고 추가기능을 고민할 때, 이 부분을 조금 더 개선하고 싶다는 생각이 들었다. WebP 포맷을 사용하면 화질 손실이 거의 없이 용량을 크게 감소시킬 수 있다는 사실을 알고 있었기 때문이다.

인코딩 과정이 들어가는 만큼 처음 게시글을 작성할 때, 즉 이미지를 처리하고 서버에 업로드할 때 기존 방식보다 시간이 더 걸리긴 하겠지만, 그 대신 로딩 속도는 훨씬 빨라지고 서버의 저장공간 역시 크게 절약할 수 있을 것이라 생각했다.

#### 1.1 시행착오

* webp가 흔하게 사용되는 포맷이 아니다보니 정보를 찾는데 어려움이 좀 있었다. 처음엔 우연히 발견한 `JDeli`라는 라이브러리를 사용해서 webp 인코딩을 구현했다.

  몇 번의 삽질 끝에 성공은 했지만, 결과물에 반전이 있었다. `JDeli`는 상용 라이브러리였고, 내가 사용한 체험판에는 워터마크와 화질제한이 있었던 것이다.

  덕분에 시간은 날렸지만 중요한 교훈을 얻었다. 라이브러리를 사용하기 전에는 항상 라이센스를 꼼꼼히 체크해야 한다는 교훈을...

* 하지만 소득이 아주 없었던 건 아니었다. `JDeli` 홈페이지의 사용설명서에는 자바 표준 입출력 라이브러리인 `JavaI/O`에 대한 이야기가 있었다.

  아마 "우리 라이브러리를 사용하면 내장 라이브러리보다 이만큼 편합니다!"를 강조하고 싶었던 것 같다. 어쨌든 덕분에 나는 `JavaI/O`를 사용해도 webp의 입출력이 가능하다는 정보를 얻었고, 이에 대해 좀 더 알아봐야겠다는 생각이 들었다.

* 프로그래밍 언어의 입출력이 으레 그렇듯, 자바 역시 마찬가지로 어렵고 복잡했다. 나 역시 `JavaI/O`에 대해 A부터 Z까지 다 공부하기보다는 당장 webp 인코딩을 구현하는 것이 우선이었다.

  알아보니 `JavaI/O`는 기본적으로 지원하는 이미지 포맷들이 있었다. 흔히들 사용하는 `png`, `jpg` 등이다. 그 외의 포맷들은 기본 지원하지는 않지만, 플러그인을 설치하면 지원이 가능하도록 만들어져 있었다. 모든 것들 갖추는 대신 확장성을 제공한 것이었다.

  webp를 지원하는 플러그인 역시 존재했고, 구글링을 통해 가장 많이 사용되는 플러그인을 찾아서 프로젝트에 도입했다.

  파일 입출력에 대한 지식이 전무한 탓에 시행착오를 좀 겪었지만, 그러면서 조금씩 익숙해졌고, 결국 이미지를 webp로 인코딩 해 서버에 업로드하는 것까지 구현에 성공했다.

  하지만 늘 그렇듯이 예상치 못한 문제들이 발생했다.

#### 1.2 문제점

* 첫 번째 문제는 작성글을 수정할 때 발생했다.

  새로 첨부한 이미지를 webp로 인코딩하고 서버에 업로드하는 것까지는 문제가 없었다. 하지만 기존의 썸네일로 쓰이던 이미지가 삭제되고 새로운 썸네일이 필요할 경우, 기존에 첨부한 이미지의 url을 통해 해당 webp파일을 다운 받고, 썸네일 크기로 리사이징 할 필요가 있었다.

  문제는 바로 여기서 발생했다. 기존의 리사이징 로직은 webp가 아닌, `png`, `jpg`등을 먼저 사이즈를 줄인 뒤, `webp`로 인코딩하는 식으로 돌아가고 있었다. 그런데 webp를 리사이징하려고 하자 예외가 발생하기 시작했다.

  결국 ***서버에서 이미지를 다운 받은 뒤, png로 디코딩하고, 리사이징 후 다시 webp로 인코딩***하는 로직을 짰다. 잘 돌아가긴 했지만 **이건 분명 뭔가 잘못됐다**는 생각이 강하게 들었다...

* 두 번째 문제는 이미지를 첨부할 때 발생했다.

  이미지의 해상도가 일정 크기 이상을 넘어가면 webp로 인코딩할 때 알 수 없는 예외가 튀어나왔다. 이건 첫 번째 문제보다 심각했다. 검색해도 원인을 추측조차 할 수가 없었다.

#### 1.3 해결책

* 첫 번째 문제는 의외로 쉽게 해결했다. 이미지 리사이징에 `Thumbnailator`라는 라이브러리를 사용 중이었는데, `Java I/O` 기반으로 돌아가는 라이브러리였다. 이게 무슨 뜻이냐면, `Java I/O`에 플러그인을 추가하면 `Thumbnailator`에서도 그것을 사용할 수 있다는 뜻이었다.

  결국 약간의 설정 변경을 통해, `Thumbnailator` 하나로 webp의 인코딩, 리사이징 전부 수행하도록 코드를 개선했다. 불필요한 코드가 대거 사라졌고, 앞서 얘기했던 webp->png->webp라는 말도 안 되는 구조도 개선되었다.
  
* 두 번째 문제는 결국 원인을 찾지 못했다. 하지만 `Thumbnailator`를 사용하자 고해상도 이미지 역시 문제 없이 webp로 인코딩하거나 리사이징이 가능해졌다. 원인은 찾지 못했지만 뒷발로 쥐 잡듯 문제를 해결해버린 것이다.

#### 1.4 결론

* 결과적으로 서비스의 모든 이미지를 webp로 처리하고 보관하는 것에 성공했다. webp는 동 화질일 때 용량이 png에 비해 26%, jpg에 비해 25~34% 가량 적다. (출처: 구글 공식 WebP 홈페이지)

  ![웹 페이지 내 컨텐츠 별 비중](/images/page-weight-by-content-type.webp)

  웹 페이지의 구성 요소 중 가장 많은 비중을 차지하는 것은 이미지다. 나머지 js, css, html을 다 합쳐도 이미지에는 한참 못 미치는 양이다.

  ![http 요청 내 컨텐츠 별 분포](/images/distribution-of-request-by-content-type.webp)

  HTTP 요청 중에서도 가장 많은 비중을 차지하는 것이 바로 이미지다.

  그만큼 이미지를 어떻게 다루느냐에 따라 웹 서비스의 속도가 결정된다고 해도 과언이 아니다. 실제로 웹 서비스 속도 최적화에 관한 방법을 찾아보면, 가장 먼저 나오는 방법이 2개 있다.

  * http 요청의 횟수를 줄여라.
  * 이미지를 압축해라.

  이 2가지는 서로 연관되어 있다. 단순하게 생각하면, 이미지 크기 x 이미지 요청 횟수 = 이미지 처리로 인한 오버헤드인 셈이다. 즉, 어느 한쪽만 줄여도 효과를 보긴 하겠지만 다른 한 쪽을 같이 손 보지 않으면 큰 개선을 기대하기 어렵다는 뜻이다.

  우선 우리 프로젝트에서는 이미지 압축에 성공했다. 남은 시간동안 http 요청까지 개선해볼 기회가 있으면 좋겠다.
